# 算法设计环节

[TOC]

## 3.2 象棋中马的遍历

### 问题描述

在 N * N 的棋盘上的任意一个位置放置一个马, 选择一套合适的移动路线使得马按照 "马走日" 的移动规则不重复地遍历棋盘上的每一个点.

扩展: 设定 "蹩马腿" 的棋子

### 简要分析

这是一道比较简单的搜索题目. DFS遍历整个搜索树, 找到一条可行的路径即可.

### 回溯法

核心函数

```C++
bool traceBack(
    int x, int y, int N, int M, int left,
    vector<vector<bool>> &visited,
    vector<int> &path);
```

- (x, y) 表示马当前的位置
- N * M 表示地图的大小
- left 表示还剩下多少个点没有访问过
- visited[i][j] 表示点(i, j)是否访问过
- paths 表示到目前为止的路径, 以0-7表示马可以走的8种路径
- 如果找到路径, 则返回true

函数处理流程:

1. 如果 left 为 0 则返回 true
2. 把当前点标识为已访问过
3. 枚举8个方向, 如果对应的移动落点还没有被访问过
  1. 将这个方向放入 path 中
  2. 向这个方向跳一步, 即递归调用 (注意 left - 1)
  3. 如果上面的递归调用返回了 true, 代表找到了路线, 也直接返回true
  4. 反之如果返回了false, 应该弹出刚刚放入path的方向
4. 返回 false (当前的状态下, 往哪个方向走都找不到路)

### 扩展要求

对于设定的蹩马腿的棋子, 直接对 visited 数组的初始值进行设定即可.

### 程序主要流程

1. 由用户输入棋盘大小, 并选择是否设定蹩马腿的棋子
2. 初始化 visited, path 数组
3. 调用函数 traceBack 回溯法寻找解
4. 若找到解, 打印输出